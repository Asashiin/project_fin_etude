const superagent = require('superagent')
const ensembl37 = 'grch37.rest.ensembl.org/'
const ensembl38 = 'rest.ensembl.org/'
async function APIEnsembl(rs, popu, size) {
  try {
    let tab = []
    for (let i = 0; i < rs.length; i++) {
      // recupération info sur Grch37 et 38
      const ensbl37 = await superagent.get(ensembl37 + 'variation/human/' + rs[i]).set('Accept', 'application/json')
      const ensbl38 = await superagent.get(ensembl38 + 'variation/human/' + rs[i]).set('Accept', 'application/json')
      let acces37 = ensbl37.body
      let acces38 = ensbl38.body
      const gwAsso = await superagent.get('www.ebi.ac.uk/gwas/beta/rest/api/associations/search/findByRsId?rsId=' + rs[i]).set('Accept', 'application/json')
      let listAsso = []
      let listInfo = []
      let listSyn = []
      for (let h in acces38.synonyms) {
        let str = acces38.synonyms[h].substr(0, 2)
        if (str === 'rs') {
          listSyn.push(acces38.synonyms[h])
        }
      }
      if (gwAsso.body._embedded.associations.length !== 0) {
        for (let x in gwAsso.body._embedded.associations) {
          if (typeof (gwAsso.body._embedded.associations[x]) !== 'undefined') {
            listAsso.push(gwAsso.body._embedded.associations[x])
          } else {
            listAsso.push('NAN')
          }
        }
        for (let z in listAsso) {
          let nr = 'NR'
          let links = {
            self: listAsso[z]._links.self.href,
            associations: listAsso[z]._links.association.href,
            study: listAsso[z]._links.study.href,
            efoTraits: listAsso[z]._links.efoTraits.href,
            snps: listAsso[z]._links.snps.href
          }
          /** Récupération lien et info lien Traits   ***/
          const gwAssoTrait = await superagent.get(links.efoTraits).set('Accept', 'application/json')
          let listTrait = []
          let traitLinks
          if (gwAssoTrait !== 'undefined') {
            for (let a in gwAssoTrait.body._embedded.efoTraits) {
              listTrait.push(gwAssoTrait.body._embedded.efoTraits[a].trait)
              traitLinks = gwAssoTrait.body._embedded.efoTraits[a].uri
            }
          }
          /** Récupération lien et info lien study  ***/
          const gwAssoStudy = await superagent.get(links.study).set('Accept', 'application/json')
          let study = {}
          if (gwAssoStudy !== 'undefined') {
            study = {
              author: gwAssoStudy.body.author,
              publicationDate: gwAssoStudy.body.publicationDate,
              publication: gwAssoStudy.body.publication,
              title: gwAssoStudy.body.title,
              initialSampleSize: gwAssoStudy.body.initialSampleSize,
              pubmedId: gwAssoStudy.body.pubmedId,
              snpCount: gwAssoStudy.body.snpCount,
              accessionId: gwAssoStudy.body.accessionId
            }
          }
          if (listAsso[z] !== 'NAN') {
            if (listAsso[z].riskFrequency === null) {
              listAsso[z].riskFrequency = nr
            }
            if (listAsso[z].range === null) {
              listAsso[z].range = nr
            }
            if (listAsso[z].pvalue === null) {
              listAsso[z].pvalue = nr
            }
            if (listAsso[z].orPerCopyNum === null) {
              listAsso[z].orPerCopyNum = nr
            }
            let resultatAsso = {
              name: listAsso[z].loci[0].strongestRiskAlleles[0].riskAlleleName,
              riskFrequency: listAsso[z].riskFrequency,
              pvalue: listAsso[z].pvalueMantissa + '*10^' + listAsso[z].pvalueExponent,
              range: listAsso[z].range,
              or: listAsso[z].orPerCopyNum,
              study: study,
              trait: {
                listname: listTrait,
                traitlink: traitLinks
              }
            }
            listInfo.push(resultatAsso)
          }
        }
      }
      // R2 -> Test: rs1042779; population: Vietnam; size: 500
      // let adr = ensembl38 + 'ld/human/' + rs[i] + '/' + popu + '?window_size=' + size
      let adr = ensembl38 + 'ld/human/' + rs[i] + '/' + popu + '?window_size=' + size
      const rcarre = await superagent.get(adr).set('Accept', 'application/json')
      let listr2 = []
      let listmaxr2 = []
      if (rcarre.body.length !== 0) {
        for (let m in rcarre.body) {
          let rd = {
            name: rcarre.body[m].variation2,
            r2: rcarre.body[m].r2
          }
          listr2.push(rd)
        }
        listr2.sort(function (a, b) {
          return a.r2 - b.r2
        })
        let index = listr2.length
        for (let n = index - 1; n > index - 6; n--) {
          if (typeof listr2[n] !== 'undefined') {
            let r = {
              nom: listr2[n].name,
              r2: listr2[n].r2
            }
            listmaxr2.push(r)
          }
        }
      }
      // Information GTEX
      const tisu = await superagent.get('rest.ensembl.org/eqtl/tissue/homo_sapiens').set('Accept', 'application/json')
      let tabtissu = Object.keys(tisu.body)
      let tabgene = []
      if (tabtissu.length !== 0) {
        for (let w in tabtissu) {
          // http://rest.ensembl.org/eqtl/variant_name/homo_sapiens/rs6538678?content-type=application/json;statistic=p-value;tissue=Thyroid
          try {
            const gtex = await superagent.get('rest.ensembl.org/eqtl/variant_name/homo_sapiens/' + rs[i] + '?statistic=p-value;tissue=' + tabtissu[w]).set('Accept', 'application/json')
            let tabl = []
            // let tabgene = []
            if (gtex.body.length !== 0) {
              if (!gtex.body.error) {
                for (let x in gtex.body) {
                  let gene = {
                    namegene: gtex.body[x].gene,
                    pvalue: gtex.body[x].value
                  }
                  tabl.push(gene)
                }
                tabl.sort(function (a, b) {
                  return a.pvalue - b.pvalue
                })
                const gtsearch = await superagent.get('rest.ensembl.org/lookup/id/' + tabl[0].namegene).set('Accept', 'application/json')
                let gen = {
                  geneid: tabl[0].namegene,
                  symbol: gtsearch.body.display_name,
                  pvalue: tabl[0].pvalue,
                  tissu: tabtissu[w]
                }
                tabgene.push(gen)
              }
            }
          } catch (err) {
            console.log('ERREUR TISSU' + err)
          }
        }
      }
      let result = {
        name: acces38.name,
        conseq: acces38.most_severe_consequence,
        maf: acces38.MAF,
        minor: acces38.minor_allele,
        location: acces38.mappings[0].location,
        location2: acces37.mappings[0].location,
        start: acces38.mappings[0].start,
        end: acces38.mappings[0].end,
        seq: acces38.mappings[0].seq_region_name,
        allele: acces38.mappings[0].allele_string,
        ancestral: acces38.ancestral_allele,
        variant: listSyn,
        clinicSigni: acces38.clinical_significance,
        gwasvalue: listInfo,
        r2: listmaxr2,
        gtexvalue: tabgene,
        pop: popu,
        size: size
      }
      tab.push(result)
    }
    return tab
  } catch (err) {
    let erreur = 'ER_API_Ensembl' + err
    return erreur
  }
}
async function searchSnpByLocation(location, popu, size, nbmax) {
  try {
    let tab = []
    let snpList = []
    for (let i = 0; i < location.length; i++) {
      if (location[i]) {
        const gw = await superagent.get('https://www.ebi.ac.uk/gwas/beta/rest/api/snpLocation/' + location[i]).set('Accept', 'application/json')
        for (let j = 0; j < gw.body._embedded.singleNucleotidePolymorphisms.length; j++) {
          if (j < nbmax) {
            snpList.push(gw.body._embedded.singleNucleotidePolymorphisms[j].rsId)
          }
        }
        let result = {
          snp: snpList,
          pop: popu,
          size: size
        }
        tab.push(result)
      }
    }
    return tab
  } catch (err) {
    let erreur = 'ER searchByLoc' + err
    return erreur
  }
}
async function searchPopu(res) {
  try {
    const popu = await superagent.get(ensembl38 + 'info/variation/populations/homo_sapiens?filter=LD').set('Accept', 'application/json')
    let listpopu = []
    for (let i in popu.body) {
      let pop = {
        name: popu.body[i].name,
        desc: popu.body[i].description
      }
      listpopu.push(pop)
    }
    return listpopu
  } catch (err) {
    let erreur = err + 'err list pop'
    return erreur
  }
}
module.exports.APIEnsembl = APIEnsembl
module.exports.searchSnpByLocation = searchSnpByLocation
module.exports.searchPopu = searchPopu
